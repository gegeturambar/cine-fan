<?php

namespace AppBundle\Repository;
use Doctrine\ORM\Query;

/**
 * MovieRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class MovieRepository extends \Doctrine\ORM\EntityRepository
{

    public function getYears(){
        $results = $this
            ->createQueryBuilder("movie")//construction de requête en DQL qui attends en param l'alias de l'entité
            //si on ne fait pas de select il fait toutes les sous requêtes avec et renvoie une entité. Sinon, il renvoi un tableau de tableau
            ->select('DISTINCT movie.releaseDate')//on ne regarde jamais la base: on regarde toujours les propriétés de l'entité donc on appelle releaseDate et non pas release_date
            ->setFirstResult(0)//a partir de 0

            ->orderBy('movie.releaseDate', 'ASC')

            ->getQuery()
            ->getResult()//getArrayResult

        ;

        return $results;

    }

    public function getMovies($request){

        $title = $request['title'];
        $releaseDate = $request['releaseDate'];

        if (array_key_exists('category', $request))
            $categ = $request['category'];
        else
            $categ = '';

	    if (array_key_exists('tags', $request))
	    {
		    $tags = $request['tags'];
		    $tags = implode(',', $tags);
	    }
	    else
		    $tags = '';

        $results = $this
            ->createQueryBuilder("movie")//construction de requête en DQL qui attends en param l'alias de l'entité
            //si on ne fait pas de select il fait toutes les sous requêtes avec et renvoie une entité.
            // Sinon, il renvoi un tableau de tableau
            ->join('movie.category', 'category');
        if($tags)
        	$results->join('movie.tags', 'tag');

        if($title!='')$results = $results->andWhere('movie.title like :title')->setParameter('title', '%'.$title.'%');
        if($categ!='')$results = $results->andWhere('category.id = :categName')->setParameter('categName', $categ);
        if($tags!='')$results = $results->andWhere('tag.id IN( :tags ) ')->setParameter('tags', $tags);
        if($releaseDate!='')$results = $results->andWhere('YEAR(movie.releaseDate) = :date')->setParameter('date', $releaseDate);

        //PETIT NEW SYMPATIQUE A SAVOIR : j'ai passé plusieurs heures avant de comprendre que doctrine de base
        //ne supportait pas la fonction YEAR en DQL !!!!!!!!!
        //
        //DONC j'ai installé cette extension  https://packagist.org/packages/beberlei/DoctrineExtensions
        //
        //pour rendre l'utilisation du year possible
        // après l'ajout du fichier mysql.yml et son ajout dans le config.yml
        //
        //
        //
        // CA MARCHE !!!

        $results = $results->setFirstResult(0)//a partir de 0
        ->orderBy('movie.title', 'ASC')
//            ->orderBy('rand()')

            ->getQuery()
            ->getResult()//getArrayResult

        ;

        //dump($results); exit;

        return $results;

    }

    public function getMoviesOfCateg($idCateg){


        $results = $this
            ->createQueryBuilder("movie")//construction de requête en DQL qui attends en param l'alias de l'entité
            //si on ne fait pas de select il fait toutes les sous requêtes avec et renvoie une entité.
            // Sinon, il renvoi un tableau de tableau
            ->join('movie.category', 'category');

        $results = $results->andWhere('category.id = :categName')->setParameter('categName', $idCateg);



        $results = $results->setFirstResult(0)//a partir de 0
        ->setMaxResults(10)
        ->orderBy('movie.title', 'ASC')
            ->getQuery()
            ->getResult()//getArrayResult

        ;

        return $results;
    }


    public function countAllMovies(){
        return $this->createQueryBuilder('movie')
            ->select('COUNT(movie)')
            ->getQuery()
            ->getSingleScalarResult();
    }


    public function categsByFilmId($id){

        $result = $this
            ->createQueryBuilder("movie")//construction de requête en DQL qui attends en param l'alias de l'entité
            //si on ne fait pas de select il fait toutes les sous requêtes avec et renvoie une entité. Sinon, il renvoi un tableau de tableau
//            ->select('movie.category')
            ->andWhere('movie.id = :id')->setParameter('id', $id)
            ->getQuery()
            ->getSingleResult()
        ;

        return $result->getCategory()->getId();


    }

	public function getMoviesById($ids = array())
	{
		if(empty($ids))
			return array();
		$limit = 5;
		$t = $this
			->createQueryBuilder("movie")
			->andWhere("movie.id IN (" . implode(',', $ids) . ")")
			->orderBy('movie.releaseDate ')
			->setMaxResults($limit)
			->getQuery()
			->getResult()
		;
		//dump($t); exit;

		return $t;
	}

	public function getMoviesPriceById($ids = array()){
		$limit = 5;
		$t = $this
			->createQueryBuilder("movie")
			->select('movie.id, movie.price')
			->andWhere("movie.id IN (" . implode(',', $ids) . ")")
			->orderBy('movie.releaseDate ')
			->setMaxResults($limit)
			->getQuery()
			->getResult()
		;
		return $t;
	}

	public function updateMoviesPrice($discount_rate){

		$prices = $this
			->createQueryBuilder("movie")
			->select( 'DISTINCT(movie.price) AS price')
			->getQuery()
			->getResult(Query::HYDRATE_OBJECT);

		foreach($prices as $key => $price){
			$price = $price['price'];
			if($price > 0 )
			{
				$new_price = $price - ($price * $discount_rate / 100);

				$t         = $this
					->createQueryBuilder("movie")
					->update()
					->set('movie.price', $new_price)
					->where(' movie.price = :oldprice')
					->setParameter("oldprice", $price)
					->getQuery();
				;
				$t->execute();
			}
		}
	}
}
